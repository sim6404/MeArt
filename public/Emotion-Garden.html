<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Emotion Garden</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600&family=Dancing+Script:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0b1020; color: #fff; overflow: hidden; }
    .root { position: fixed; inset: 0; }
    canvas { position: absolute; inset: 0; width: 100%; height: 100%; cursor: pointer; background: transparent; }
    .overlay { position: absolute; inset: 0; pointer-events: none; }
    .panel { pointer-events: auto; }
    .welcome, .results { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; }
    .card { text-align: center; padding: 32px; background: rgba(255,255,255,0.8); backdrop-filter: blur(12px); border-radius: 24px; box-shadow: 0 20px 60px rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.6); max-width: 720px; width: calc(100% - 32px); }
    .title { font: 400 36px 'Dancing Script', cursive; color: #222; margin: 0 0 12px; }
    .subtitle { font: 400 18px 'Noto Sans KR', sans-serif; color: #444; margin: 0 0 24px; line-height: 1.6; }
    .label { font: 500 13px 'Noto Sans KR', sans-serif; color: #666; margin: 14px 0 8px; text-align: left; }
    .select, .range, .file { width: 100%; border-radius: 999px; padding: 12px 16px; border: 1px solid #e3e7ef; background: rgba(255,255,255,0.7); color: #333; outline: none; font: 400 15px 'Noto Sans KR', sans-serif; }
    .btn { display: inline-block; border-radius: 999px; padding: 14px 28px; border: 1px solid rgba(255,255,255,0.6); background: rgba(255,255,255,0.7); color: #333; font: 500 18px 'Noto Sans KR', sans-serif; cursor: pointer; }
    .pill { position: absolute; bottom: 24px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.85); color:#333; border-radius: 999px; border: 1px solid rgba(255,255,255,0.6); padding: 10px 16px; box-shadow: 0 10px 28px rgba(0,0,0,0.2); font: 500 14px 'Noto Sans KR', sans-serif; }
    .hud { position: absolute; top: 20px; left: 20px; background: rgba(255,255,255,0.6); color:#333; border-radius: 16px; padding: 14px; border: 1px solid rgba(255,255,255,0.5); box-shadow: 0 10px 32px rgba(0,0,0,0.2); width: 240px; }
    .hud .row { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
    .hud .k { font: 300 12px 'Noto Sans KR', sans-serif; color:#555; }
    .hud .v { font: 400 18px 'Noto Sans KR', sans-serif; color:#222; }
    .top-right { position: absolute; top: 14px; right: 14px; display: flex; gap: 8px; }
    .ghost { background: rgba(0,0,0,0.35); color:#fff; border: 1px solid rgba(255,255,255,0.35); }
  </style>
</head>
<body>
  <div class="root">
    <canvas id="gardenCanvas"></canvas>
    <div class="overlay">
      <div class="top-right panel">
        <button class="btn ghost" id="btnRestart">ë‹¤ì‹œ ì‹œì‘</button>
        <button class="btn ghost" id="btnClose">ë‹«ê¸°</button>
      </div>

      <div class="welcome panel" id="welcomePanel">
        <div class="card">
          <h1 class="title">Emotion Garden</h1>
          <p class="subtitle">ë¸ŒëŸ¬ì‹œ íš¨ê³¼ ê²°ê³¼ ì´ë¯¸ì§€ë¥¼ ë°°ê²½ìœ¼ë¡œ, ë‹¹ì‹ ì˜ ê°ì •ì— ê³µê°í•˜ëŠ” ë©”ì‹œì§€ë¥¼ ì°¾ì•„ë³´ì„¸ìš”.</p>

          <div>
            <div class="label">í˜„ì¬ ê°ì • ìƒíƒœ</div>
            <select class="select" id="selectEmotion">
              <option value="joy">ê¸°ì¨</option>
              <option value="sadness">ìŠ¬í””</option>
              <option value="anger">ë¶„ë…¸</option>
              <option value="fear">ë‘ë ¤ì›€</option>
              <option value="anxiety">ë¶ˆì•ˆ</option>
              <option value="love">ì‚¬ë‘</option>
              <option value="gratitude">ê°ì‚¬</option>
              <option value="loneliness">ì™¸ë¡œì›€</option>
              <option value="peace">í‰ì˜¨</option>
              <option value="excitement">í¥ë¶„</option>
              <option value="neutral">ì¤‘ë¦½</option>
            </select>

            <div class="label">ê°ì • ê°•ë„: <span id="intensityText">60%</span></div>
            <input type="range" min="0" max="1" step="0.1" value="0.6" class="range" id="rangeIntensity" />

            <div class="label">ë°°ê²½ ì´ë¯¸ì§€ (ì„ íƒ) â€” ìë™ìœ¼ë¡œ ë¸ŒëŸ¬ì‹œ ê²°ê³¼ë¥¼ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤</div>
            <input type="file" accept="image/*" class="file" id="fileInput" />
          </div>

          <div style="margin-top: 22px;">
            <button class="btn" id="btnStart">ê°ì • ì •ì› ì‹œì‘í•˜ê¸°</button>
          </div>
        </div>
      </div>

      <div class="hud panel" id="hudPanel" style="display:none;">
        <div class="row">
          <div class="k">íƒí—˜ ì‹œê°„</div>
          <div class="v" id="txtTime">0:00</div>
        </div>
        <div class="row">
          <div class="k">í˜„ì¬ ê°ì •</div>
          <div class="v" id="txtEmotion">ì¤‘ë¦½</div>
        </div>
        <div class="row">
          <div class="k">ë©”ì‹œì§€</div>
          <div class="v" id="txtMsgCount">0</div>
        </div>
        <button class="btn" id="btnFinish" style="width:100%; margin-top:6px;">íƒí—˜ ë§ˆì¹˜ê¸°</button>
      </div>

      <div class="results panel" id="resultsPanel" style="display:none;">
        <div class="card" style="max-width:640px;">
          <h2 class="title" style="font-size:30px;">ê°ì • ì—¬í–‰ì˜ ê¸°ë¡</h2>
          <div class="subtitle" style="margin-bottom: 16px;">
            <span id="summaryTime">0:00</span> ë™ì•ˆ <span id="summaryCount">0</span>ê°œì˜ ë©”ì‹œì§€ë¥¼ ë°œê²¬í–ˆì–´ìš”.
          </div>
          <div id="messageList" style="max-height:260px; overflow:auto; text-align:left; padding:12px; background: rgba(255,255,255,0.6); border-radius:12px;"></div>
          <div style="margin-top:18px;">
            <button class="btn" id="btnNew">ìƒˆë¡œìš´ ê°ì • ì—¬í–‰í•˜ê¸°</button>
          </div>
        </div>
      </div>

      <div class="pill panel" id="hint" style="display:none;">ì”ë””ë¥¼ í´ë¦­í•˜ì—¬ ê°ì • ë©”ì‹œì§€ë¥¼ ë°œê²¬í•˜ì„¸ìš” ğŸŒ±ğŸ’</div>
    </div>
  </div>

  <script>
    const STATIC_GRASS = false; // ì”ë”” ìì—°ìŠ¤ëŸ¬ìš´ í”ë“¤ë¦¼ ë° ìƒí˜¸ì‘ìš© í™œì„±í™”
    // ====== ìœ í‹¸: ì´ˆê¸° ë°ì´í„° ìˆ˜ì§‘ (ë°°ê²½/ê°ì •) ======
    function getQueryParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    function pickBackgroundUrl() {
      // ìš°ì„ ìˆœìœ„: URL bg -> localStorage.imageBase64 -> localStorage.processedImageUrl -> localStorage.brushResultImageUrl
      const fromUrl = getQueryParam('bg');
      if (fromUrl) return decodeURIComponent(fromUrl);
      const imageBase64 = localStorage.getItem('imageBase64');
      if (imageBase64) return imageBase64;
      const processed = localStorage.getItem('processedImageUrl');
      if (processed) return processed;
      const brush = localStorage.getItem('brushResultImageUrl');
      if (brush) return brush;
      return null;
    }

    function normalizeEmotion(raw) {
      if (!raw) return 'neutral';
      const key = String(raw).toLowerCase();
      const map = {
        happy: 'joy', happiness: 'joy', joy: 'joy',
        sad: 'sadness', sadness: 'sadness',
        angry: 'anger', anger: 'anger',
        fear: 'fear', fearful: 'fear',
        disgust: 'anxiety', contempt: 'anxiety', anxiety: 'anxiety',
        love: 'love',
        gratitude: 'gratitude',
        loneliness: 'loneliness',
        peace: 'peace', calm: 'peace', neutral: 'neutral',
        surprise: 'excitement', surprised: 'excitement', excitement: 'excitement'
      };
      return map[key] || 'neutral';
    }

    function pickEmotion() {
      const fromUrl = getQueryParam('emotion');
      if (fromUrl) return normalizeEmotion(fromUrl);
      const lsEmotion = localStorage.getItem('emotion');
      if (lsEmotion) return normalizeEmotion(lsEmotion);
      try {
        const analysis = JSON.parse(localStorage.getItem('emotionAnalysis') || 'null');
        if (analysis && analysis.emotion) return normalizeEmotion(analysis.emotion);
      } catch {}
      return 'neutral';
    }

    function pickIntensity() {
      const fromUrl = parseFloat(getQueryParam('intensity'));
      if (!Number.isNaN(fromUrl)) return Math.min(1, Math.max(0, fromUrl));
      try {
        const analysis = JSON.parse(localStorage.getItem('emotionAnalysis') || 'null');
        if (analysis && (typeof analysis.confidence === 'number')) {
          return Math.min(1, Math.max(0, analysis.confidence));
        }
      } catch {}
      return 0.6;
    }

    // ====== ìƒíƒœ ======
    const state = {
      canvas: null,
      ctx: null,
      screen: { width: window.innerWidth, height: window.innerHeight },
      phase: 'welcome',
      transitioning: false,
      emotion: 'neutral',
      intensity: 0.6,
      particles: [],
      grass: [],
      hiddenSpots: [],
      floatingMessages: [],
      emojis: [],
      activeMsgPositions: [],
      backgroundImage: null,
      timerRunning: false,
      secondsExploring: 0,
      timerInterval: null,
      foundMessages: [],
      recentMessages: [],
      mouse: { x: 0, y: 0, inside: false }
    };

    const el = {
      welcome: null, results: null, hud: null, hint: null,
      selectEmotion: null, rangeIntensity: null, intensityText: null,
      txtTime: null, txtEmotion: null, txtMsgCount: null,
      messageList: null, summaryTime: null, summaryCount: null,
      btnStart: null, btnFinish: null, btnNew: null, btnClose: null, btnRestart: null, fileInput: null
    };

    // ====== ê°ì • íƒ€ì…/ì´ëª¨ì§€ ======
    const emotionTypes = {
      joy: { color: '#FFD700', particles: 'sparkles', label: 'ê¸°ì¨' },
      sadness: { color: '#4A90E2', particles: 'tears', label: 'ìŠ¬í””' },
      anger: { color: '#FF6B6B', particles: 'flames', label: 'ë¶„ë…¸' },
      fear: { color: '#9B59B6', particles: 'shadows', label: 'ë‘ë ¤ì›€' },
      anxiety: { color: '#95A5A6', particles: 'swirls', label: 'ë¶ˆì•ˆ' },
      love: { color: '#E91E63', particles: 'hearts', label: 'ì‚¬ë‘' },
      gratitude: { color: '#27AE60', particles: 'light', label: 'ê°ì‚¬' },
      loneliness: { color: '#7F8C8D', particles: 'mist', label: 'ì™¸ë¡œì›€' },
      peace: { color: '#3498DB', particles: 'bubbles', label: 'í‰ì˜¨' },
      excitement: { color: '#F39C12', particles: 'confetti', label: 'í¥ë¶„' },
      neutral: { color: '#BDC3C7', particles: 'dots', label: 'ì¤‘ë¦½' }
    };

    const emojiMap = {
      joy: ['ğŸŒ»','ğŸŒ¸','âœ¨','ğŸ’›','â˜€ï¸','ğŸŒˆ'],
      sadness: ['ğŸ’§','ğŸŒ§ï¸','ğŸ’™','ğŸŒ™','ğŸ’œ'],
      anger: ['ğŸ”¥','âš¡','ğŸ’¥','ğŸŒ‹'],
      fear: ['ğŸŒ«ï¸','ğŸ‘»','ğŸŒªï¸','ğŸ’¨'],
      anxiety: ['ğŸŒªï¸','ğŸ’­','ğŸ˜°','ğŸŒŠ'],
      love: ['ğŸ’–','ğŸŒ¹','ğŸ’•','ğŸ’—','ğŸ¥°'],
      gratitude: ['ğŸ™','âœ¨','ğŸŒŸ','ğŸ’š','ğŸŒº'],
      loneliness: ['ğŸŒ™','â­','ğŸ•¯ï¸','ğŸ’™','ğŸŒŒ'],
      peace: ['ğŸ•Šï¸','ğŸŒ¸','â˜ï¸','ğŸ¤','ğŸŒ¿'],
      excitement: ['ğŸ‰','ğŸŠ','âš¡','ğŸŒŸ','ğŸ’¥'],
      neutral: ['ğŸŒ¿','ğŸƒ','ğŸ’«','ğŸŒ±','âœ¨']
    };

    // ====== ë©”ì‹œì§€ ì˜ˆì‹œ (ì¶•ì•½ë³¸) ======
    const messageExamples = {
      joy: {
        gentle: [
          'ê¸°ì¨ì€ ì‚¶ì˜ ì•„ë¦„ë‹¤ìš´ ìˆœê°„ë“¤ì„ ë§Œë“¤ì–´ê°‘ë‹ˆë‹¤',
          'í–‰ë³µì€ ë§ˆìŒì˜ ì„ íƒì´ë©° ì§€ê¸ˆ ì´ ìˆœê°„ì— ì¡´ì¬í•©ë‹ˆë‹¤',
          'í™˜í•œ ë¯¸ì†ŒëŠ” ë§ˆìŒì˜ í–‡ì‚´ì…ë‹ˆë‹¤',
          'ì‘ì€ ì¦ê±°ì›€ì´ í•˜ë£¨ë¥¼ ë°˜ì§ì´ê²Œ í•©ë‹ˆë‹¤',
          'ê¸°ìœ ë§ˆìŒì€ ì£¼ë³€ê¹Œì§€ ë”°ëœ»í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤'
        ],
        understanding: [
          'í–‰ë³µí•œ ë§ˆìŒì€ í¬ë§ì˜ ì”¨ì•—ì„ ì‹¬ì–´ì¤ë‹ˆë‹¤',
          'ê¸°ì¨ì€ ë‚˜ëˆŒìˆ˜ë¡ ì»¤ì§‘ë‹ˆë‹¤',
          'ê°ì‚¬ì˜ ì‹œì„ ì´ ê¸°ì¨ì„ ë¶€ë¦…ë‹ˆë‹¤',
          'ë§ˆìŒì´ ë°ìœ¼ë©´ ì„¸ìƒë„ í™˜í•´ì§‘ë‹ˆë‹¤'
        ],
        deep: [
          'í–‰ë³µì€ ëª©ì ì§€ê°€ ì•„ë‹ˆë¼ ì—¬í–‰ ê·¸ ìì²´ì…ë‹ˆë‹¤',
          'ì§„ì •í•œ ê¸°ì¨ì€ ë‚´ë©´ì—ì„œ í”¼ì–´ë‚©ë‹ˆë‹¤',
          'ì‘ì€ ê°ì‚¬ë“¤ì´ í° í–‰ë³µì„ ë§Œë“­ë‹ˆë‹¤'
        ]
      },
      sadness: {
        gentle: [
          'ëˆˆë¬¼ì€ ë§ˆìŒì˜ ì •í™”ì´ë©° ìƒˆë¡œìš´ ì‹œì‘ì˜ ì¤€ë¹„ì…ë‹ˆë‹¤',
          'ìŠ¬í””ì€ ì§€ì¹œ ë§ˆìŒì„ ì‰¬ê²Œ í•©ë‹ˆë‹¤',
          'ì´ ìˆœê°„ì˜ ì•„í””ë„ ì§€ë‚˜ê°‘ë‹ˆë‹¤',
          'ë‹¹ì‹ ì˜ ìŠ¬í””ì€ ì†Œì¤‘í•œ ë§ˆìŒì˜ í‘œí˜„ì…ë‹ˆë‹¤'
        ],
        understanding: [
          'ìŠ¬í””ì€ ì‚¬ë‘í–ˆë‹¤ëŠ” ì¦ëª…ì…ë‹ˆë‹¤',
          'ìƒì‹¤ì€ ë§ˆìŒì´ ê¹Šë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤',
          'ì•„í””ì€ ì¹˜ìœ ë¥¼ í–¥í•œ ê³¼ì •ì…ë‹ˆë‹¤',
          'ìŠ¤ìŠ¤ë¡œë¥¼ ë‹¤ì •í•˜ê²Œ ì•ˆì•„ì£¼ì„¸ìš”'
        ],
        deep: [
          'ìŠ¬í”” ë’¤ì—ëŠ” ìƒˆë¡œìš´ í¬ë§ì˜ ë¬¸ì´ ì—´ë ¤ìˆìŠµë‹ˆë‹¤',
          'ì–´ë‘ ì´ ê¹Šì„ìˆ˜ë¡ ìƒˆë²½ì€ ê°€ê¹Œì›Œì§‘ë‹ˆë‹¤',
          'ìƒì²˜ëŠ” ë” í° ì´í•´ë¡œ ì´ì–´ì§‘ë‹ˆë‹¤'
        ]
      },
      anger: {
        gentle: [
          'ë¶„ë…¸ëŠ” ì†Œì¤‘í•œ ê²ƒì„ ì§€í‚¤ë ¤ëŠ” ë§ˆìŒì—ì„œ ë‚˜ì˜µë‹ˆë‹¤',
          'í™”ì˜ ì´ë©´ì—ëŠ” ìƒì²˜ê°€ ìˆìŠµë‹ˆë‹¤',
          'ìŠ¤ìŠ¤ë¡œì—ê²Œ ì ì‹œ ì‹œê°„ì„ ì£¼ì„¸ìš”',
          'í˜¸í¡ì€ ë§ˆìŒì„ ì°¨ë¶„í•˜ê²Œ ë•ìŠµë‹ˆë‹¤'
        ],
        understanding: [
          'ë¶„ë…¸ëŠ” ë³€í™”ë¥¼ ìœ„í•œ ì—ë„ˆì§€ì…ë‹ˆë‹¤',
          'ê²½ê³„ëŠ” ì¡´ì¤‘ì„ ì§€í‚¤ê¸° ìœ„í•œ ì„ íƒì…ë‹ˆë‹¤',
          'ê°ì •ì€ ì˜³ê³  ê·¸ë¦„ì´ ì•„ë‹ˆë¼ ì‹ í˜¸ì…ë‹ˆë‹¤',
          'í™”ë¥¼ ì•Œì•„ì°¨ë¦´ ë•Œ ì§€í˜œê°€ ì‹œì‘ë©ë‹ˆë‹¤'
        ],
        deep: [
          'ë¶„ë…¸ ë’¤ì˜ ìƒì²˜ë¥¼ ì¹˜ìœ í•  ë•Œ í‰í™”ë¥¼ ì°¾ìŠµë‹ˆë‹¤',
          'ë‹¨ë‹¨í•œ ë§ˆìŒì€ ë‹¤ì •í•¨ìœ¼ë¡œ ê°•í•´ì§‘ë‹ˆë‹¤',
          'ì´í•´ëŠ” ì˜¨í™”í•œ í˜ì„ ë§Œë“­ë‹ˆë‹¤'
        ]
      },
      fear: {
        gentle: [
          'ìš©ê¸°ëŠ” ë‘ë ¤ì›€ê³¼ í•¨ê»˜ ê±¸ì–´ê°€ëŠ” ê²ƒì…ë‹ˆë‹¤',
          'ì‘ì€ í•œ ê±¸ìŒì´ ì¶©ë¶„í•©ë‹ˆë‹¤',
          'ê´œì°®ì•„ìš”, ì²œì²œíˆ ë‚˜ì•„ê°€ë©´ ë©ë‹ˆë‹¤',
          'ë‘ë ¤ì›€ì€ ì£¼ì˜ë¥¼ ê¸°ìš¸ì´ë¼ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤'
        ],
        understanding: [
          'ë‘ë ¤ì›€ì€ ì†Œì¤‘í•œ ê²ƒì„ ì§€í‚¤ë ¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤',
          'ì•ˆì „í•¨ì„ í™•ë³´í•˜ëŠ” ê²ƒì´ ì²«ê±¸ìŒì…ë‹ˆë‹¤',
          'ìŠ¤ìŠ¤ë¡œë¥¼ ë¯¿ëŠ” ì—°ìŠµì´ í•„ìš”í•©ë‹ˆë‹¤',
          'ì§€ê¸ˆ ì´ ìˆœê°„ì— ë¨¸ë¬¼ëŸ¬ ë³´ì„¸ìš”'
        ],
        deep: [
          'ë‘ë ¤ì›€ì„ ë§ˆì£¼í•  ë•Œ ì§„ì •í•œ ìì‹ ì„ ë°œê²¬í•©ë‹ˆë‹¤',
          'ë¹›ì€ í”ë“¤ë¦¬ëŠ” ë§ˆìŒ ì†ì—ì„œë„ í”¼ì–´ë‚©ë‹ˆë‹¤',
          'ìš©ê¸°ë€ ë‘ë ¤ì›€ì´ ìˆì–´ë„ ì„ íƒí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤'
        ]
      },
      anxiety: {
        gentle: [
          'ë¶ˆì•ˆí•  ë• í˜¸í¡ì— ì§‘ì¤‘í•˜ë©° í˜„ì¬ë¡œ ëŒì•„ì˜¤ì„¸ìš”',
          'ì˜¤ëŠ˜ì„ ë²„í‹°ëŠ” ê²ƒë§Œìœ¼ë¡œë„ ì¶©ë¶„í•©ë‹ˆë‹¤',
          'ì™„ë²½í•¨ ëŒ€ì‹  ì¶©ë¶„í•¨ì„ ì„ íƒí•´ ë³´ì„¸ìš”',
          'ëª¸ì˜ ê°ê°ì— ì²œì²œíˆ ì£¼ì˜ë¥¼ ëŒë ¤ë³´ì„¸ìš”'
        ],
        understanding: [
          'ê±±ì •ì€ ì„¸ì‹¬í•¨ì˜ ë˜ ë‹¤ë¥¸ í‘œí˜„ì…ë‹ˆë‹¤',
          'ë¶ˆí™•ì‹¤í•¨ ì†ì—ì„œë„ í•  ìˆ˜ ìˆëŠ” ì¼ì´ ìˆìŠµë‹ˆë‹¤',
          'ì‘ê²Œ ìª¼ê°œë©´ ê°ë‹¹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
          'ë„ì›€ ìš”ì²­ì€ ìš©ê¸° ìˆëŠ” í–‰ë™ì…ë‹ˆë‹¤'
        ],
        deep: [
          'ë¶ˆì•ˆì€ í˜„ì¬ì— ì§‘ì¤‘í•˜ë¼ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤',
          'ë§ˆìŒì˜ íŒŒë„ëŠ” ì ì‹œ í›„ ì”ì”í•´ì§‘ë‹ˆë‹¤',
          'ìë¹„ëŠ” ë¶ˆì•ˆì„ í’ˆëŠ” ê°€ì¥ ë”°ëœ»í•œ íƒœë„ì…ë‹ˆë‹¤'
        ]
      },
      love: {
        gentle: [
          'ì‚¬ë‘ì€ ê°€ì¥ ê°•ë ¥í•œ ì—ë„ˆì§€ì…ë‹ˆë‹¤',
          'ë‹¤ì •í•¨ì€ ì‚¬ë‘ì˜ ë‹¤ë¥¸ ì´ë¦„ì…ë‹ˆë‹¤',
          'ë°›ëŠ” ì‚¬ë‘ë§Œí¼ ì£¼ëŠ” ì‚¬ë‘ë„ ì†Œì¤‘í•©ë‹ˆë‹¤',
          'ìì‹ ì„ ì‚¬ë‘í•˜ëŠ” ìˆœê°„ ì„¸ìƒì´ ë‹¬ë¼ì§‘ë‹ˆë‹¤'
        ],
        understanding: [
          'ìì‹ ì„ ì‚¬ë‘í•˜ëŠ” ë²•ë¶€í„°',
          'ì‚¬ë‘ì€ ëŒë´„ê³¼ ì±…ì„ì„ í¬í•¨í•©ë‹ˆë‹¤',
          'ì‚¬ë‘ì€ ì„±ì¥í•˜ë ¤ëŠ” ì˜ì§€ì…ë‹ˆë‹¤',
          'ì‚¬ë‘ì€ ì¼ìƒì˜ ì„ íƒì…ë‹ˆë‹¤'
        ],
        deep: [
          'ì‚¬ë‘ì€ ì˜í˜¼ì˜ í™•ì¥ì…ë‹ˆë‹¤',
          'ê¹Šì€ ì‚¬ë‘ì€ ë‘ë ¤ì›€ì„ ì¤„ì…ë‹ˆë‹¤',
          'ì‚¬ë‘ì€ í•¨ê»˜ ìë¼ëŠ” ê²½í—˜ì…ë‹ˆë‹¤'
        ]
      },
      gratitude: {
        gentle: [
          'ê°ì‚¬ëŠ” ì‘ì€ ê¸°ì ì„ ë°œê²¬í•˜ê²Œ í•©ë‹ˆë‹¤',
          'ì˜¤ëŠ˜ì˜ ì‘ì€ í–‰ìš´ì„ ê¸°ë¡í•´ ë³´ì„¸ìš”',
          'ê³ ë§ˆì›€ì€ ë§ˆìŒì„ ë¶€ìœ í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤',
          'ì‚¬ì†Œí•¨ ì†ì— ì„ ë¬¼ì´ ìˆ¨ì–´ ìˆìŠµë‹ˆë‹¤'
        ],
        understanding: [
          'ê°ì‚¬ëŠ” í’ìš”ë¡œì›€ì— ì´ˆì ',
          'ìˆëŠ” ê²ƒì— ì£¼ëª©í•˜ë©´ ë” ë§ì´ ë³´ì…ë‹ˆë‹¤',
          'ê°ì‚¬ í‘œí˜„ì€ ê´€ê³„ë¥¼ ë‹¨ë‹¨íˆ í•©ë‹ˆë‹¤',
          'ë‚˜ëˆ”ì€ ê°ì‚¬ì˜ ë˜ ë‹¤ë¥¸ ì–¼êµ´ì…ë‹ˆë‹¤'
        ],
        deep: [
          'ê°ì‚¬ëŠ” í˜„ì¬ë¥¼ ì„ ë¬¼ë¡œ ë°›ì•„ë“¤ì´ëŠ” ì‹¤ì²œ',
          'ê°ì‚¬ëŠ” ë§ˆìŒì˜ í‰ì•ˆì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤',
          'ê°ì‚¬ëŠ” ìƒì²˜ë¥¼ ì˜ë¯¸ë¡œ ë°”ê¿‰ë‹ˆë‹¤'
        ]
      },
      loneliness: {
        gentle: [
          'ì™¸ë¡œìš´ ì‹œê°„ì€ ìì‹ ê³¼ ë§Œë‚˜ëŠ” ê¸°íšŒ',
          'ê³ ìš” ì†ì— ë§ˆìŒì˜ ì†Œë¦¬ë¥¼ ë“¤ì–´ë³´ì„¸ìš”',
          'í˜¼ìì¸ ìˆœê°„ì—ë„ ë‹¹ì‹ ì€ ì¶©ë¶„í•©ë‹ˆë‹¤',
          'ì™¸ë¡œì›€ì€ ì—°ê²°ì„ í–¥í•œ ìì—°ìŠ¤ëŸ¬ìš´ ìš•êµ¬ì…ë‹ˆë‹¤'
        ],
        understanding: [
          'ë” ê¹Šì€ ê´€ê³„ë¥¼ ì›í•˜ëŠ” ë§ˆìŒ',
          'ë‚˜ë¥¼ ìˆëŠ” ê·¸ëŒ€ë¡œ ë³´ì—¬ì£¼ëŠ” ì—°ìŠµ',
          'ì—°ê²°ì€ ì‘ì€ ì¸ì‚¬ì—ì„œ ì‹œì‘í•©ë‹ˆë‹¤',
          'ìƒì²˜ë¥¼ ë‚˜ëˆŒ ë•Œ ì¹œë°€ê°ì´ ìëë‹ˆë‹¤'
        ],
        deep: [
          'ì™¸ë¡œì›€ ì†ì—ì„œ ì§„ì •í•œ ìì•„ë¥¼ ë§Œë‚©ë‹ˆë‹¤',
          'ìê¸° ìˆ˜ìš©ì€ ê³ ë…ì„ ì„±ì¥ìœ¼ë¡œ ë°”ê¿‰ë‹ˆë‹¤',
          'í˜¼ìì¼ ìˆ˜ ìˆì§€ë§Œ ì™¸ë¡­ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤'
        ]
      },
      peace: {
        gentle: [
          'í‰ì˜¨ì€ ë‚´ë©´ì˜ ì•ˆì‹ì²˜ì…ë‹ˆë‹¤',
          'ì²œì²œíˆ ìˆ¨ì„ ë“¤ì´ë§ˆì‹œê³  ë‚´ì‰¬ì–´ ë³´ì„¸ìš”',
          'ì¡°ìš©í•œ ìˆœê°„ì´ ë§ˆìŒì„ íšŒë³µì‹œí‚µë‹ˆë‹¤',
          'ë¹„ì›€ì€ í‰ì˜¨ì„ ë¶€ë¦…ë‹ˆë‹¤'
        ],
        understanding: [
          'ë¶ˆì™„ì „í•¨ì„ ë°›ì•„ë“¤ì¼ ë•Œ í‰í™”ê°€ ì˜µë‹ˆë‹¤',
          'ë©ˆì¶¤ì€ ì§€í˜œì˜ ì‹œì‘ì…ë‹ˆë‹¤',
          'ê²½ìŸ ëŒ€ì‹  ê³µì¡´ì„ ì„ íƒí•´ ë³´ì„¸ìš”',
          'ëŠë¦¼ì€ ê¹Šì´ë¥¼ ë§Œë“­ë‹ˆë‹¤'
        ],
        deep: [
          'ì§„ì •í•œ í‰ì˜¨ì€ ì˜í˜¼ì˜ ììœ ',
          'ê³ ìš” ì†ì—ì„œ ë°©í–¥ì„ ì°¾ìŠµë‹ˆë‹¤',
          'í‰í™”ëŠ” ì„ íƒì˜ ê²°ê³¼ì…ë‹ˆë‹¤'
        ]
      },
      excitement: {
        gentle: [
          'ì„¤ë ˜ì€ ì•„ë¦„ë‹¤ìš´ ì—ë„ˆì§€',
          'ì‘ì€ ë„ì „ì´ í° ê¸°ì¨ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤',
          'ìƒˆë¡œì›€ì€ ë§ˆìŒì„ ê¹¨ì›ë‹ˆë‹¤',
          'ì¦ê±°ìš´ ê¸°ëŒ€ê°€ ë‚ ê°œë¥¼ ë‹¬ì•„ì¤ë‹ˆë‹¤'
        ],
        understanding: [
          'í¥ë¶„ì€ ì‚¶ì— ì°¸ì—¬í•œë‹¤ëŠ” ì‹ í˜¸',
          'ì—´ì •ì€ ë°©í–¥ì„ í•„ìš”ë¡œ í•©ë‹ˆë‹¤',
          'ì§‘ì¤‘ì€ ì—ë„ˆì§€ë¥¼ í•˜ë‚˜ë¡œ ëª¨ìë‹ˆë‹¤',
          'ëª°ì…ì€ ì‹œê°„ì„ ì„ ë¬¼ì²˜ëŸ¼ ë°”ê¿‰ë‹ˆë‹¤'
        ],
        deep: [
          'í˜„ì¬ì— ëª°ì…í•  ë•Œ ìƒëª…ì˜ ì¶©ë§Œí•¨',
          'ì—´ì •ì€ ì˜ë¯¸ì™€ ë§Œë‚  ë•Œ ì˜¤ë˜ê°‘ë‹ˆë‹¤',
          'ê°€ìŠ´ ë›°ëŠ” ì¼ì€ ì‚¶ì„ í™•ì¥í•©ë‹ˆë‹¤'
        ]
      },
      neutral: {
        gentle: [
          'ê³ ìš”í•¨ ì†ì— ì§€í˜œê°€ ìˆìŠµë‹ˆë‹¤',
          'ì°¨ë¶„í•¨ì€ ì„¸ë ¨ëœ ì•„ë¦„ë‹¤ì›€',
          'ê· í˜• ì¡íŒ ì‹œì„ ì´ í‰ì˜¨ì„ ë§Œë“­ë‹ˆë‹¤',
          'ì§€ê¸ˆ ì´ëŒ€ë¡œ ì¶©ë¶„í•©ë‹ˆë‹¤'
        ],
        understanding: [
          'ë‹´ë°±í•¨ì€ ë§ˆìŒì„ ê°€ë³ê²Œ í•©ë‹ˆë‹¤',
          'ì¤‘ë¦½ì€ ë„“ì€ ì´í•´ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤',
          'íŒë‹¨ì„ ëŠ¦ì¶”ë©´ ë³´ì´ëŠ” ê²ƒì´ ë§ì•„ì§‘ë‹ˆë‹¤',
          'ëŠìŠ¨í•¨ì€ ì°½ì˜ì„±ì„ ë•ìŠµë‹ˆë‹¤'
        ],
        deep: [
          'í‰ì˜¨ì€ ì™¸ë¶€ì— ì˜ì¡´í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤',
          'ìˆëŠ” ê·¸ëŒ€ë¡œì˜ í˜„ì‹¤ì„ ë°›ì•„ë“¤ì¼ ë•Œ ììœ ê°€ ì˜µë‹ˆë‹¤',
          'ê³ ìš”ëŠ” ìƒˆë¡œìš´ ì‹œì‘ì˜ ë°”íƒ•ì…ë‹ˆë‹¤'
        ]
      }
    };

    // ====== ì´ˆê¸°í™” ======
    function initDom() {
      state.canvas = document.getElementById('gardenCanvas');
      state.ctx = state.canvas.getContext('2d');
      el.welcome = document.getElementById('welcomePanel');
      el.results = document.getElementById('resultsPanel');
      el.hud = document.getElementById('hudPanel');
      el.hint = document.getElementById('hint');
      el.selectEmotion = document.getElementById('selectEmotion');
      el.rangeIntensity = document.getElementById('rangeIntensity');
      el.intensityText = document.getElementById('intensityText');
      el.txtTime = document.getElementById('txtTime');
      el.txtEmotion = document.getElementById('txtEmotion');
      el.txtMsgCount = document.getElementById('txtMsgCount');
      el.messageList = document.getElementById('messageList');
      el.summaryTime = document.getElementById('summaryTime');
      el.summaryCount = document.getElementById('summaryCount');
      el.btnStart = document.getElementById('btnStart');
      el.btnFinish = document.getElementById('btnFinish');
      el.btnNew = document.getElementById('btnNew');
      el.btnClose = document.getElementById('btnClose');
      el.btnRestart = document.getElementById('btnRestart');
      el.fileInput = document.getElementById('fileInput');

      resizeCanvas();
      window.addEventListener('resize', () => {
        state.screen = { width: window.innerWidth, height: window.innerHeight };
        resizeCanvas();
        rebuildGrassAndSpots();
      });
      state.canvas.addEventListener('mousemove', handleMouseMove);
      state.canvas.addEventListener('mouseleave', handleMouseLeave);
      state.canvas.addEventListener('click', handleCanvasClick);

      el.rangeIntensity.addEventListener('input', () => {
        state.intensity = parseFloat(el.rangeIntensity.value);
        el.intensityText.textContent = Math.round(state.intensity * 100) + '%';
        rebuildSpotsAndParticles();
      });
      el.selectEmotion.addEventListener('change', () => {
        state.emotion = el.selectEmotion.value;
        updateHUDEmotion();
        rebuildSpotsAndParticles();
      });
      el.btnStart.addEventListener('click', startExploration);
      el.btnFinish.addEventListener('click', finishExploration);
      el.btnNew.addEventListener('click', restartGame);
      el.btnClose.addEventListener('click', () => window.close());
      el.btnRestart.addEventListener('click', restartGame);
      el.fileInput.addEventListener('change', onFileSelected);
    }

    function resizeCanvas() {
      state.canvas.width = state.screen.width;
      state.canvas.height = state.screen.height;
    }

    function onFileSelected(e) {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => {
        const img = new Image();
        img.onload = () => { state.backgroundImage = img; };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    }

    // ====== ë°ì´í„° ë¡œë“œ ======
    function loadBackgroundImageIfAny() {
      const url = pickBackgroundUrl();
      if (!url) return;
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => { state.backgroundImage = img; };
      img.src = url;
    }

    // ====== íŒŒí‹°í´/ì”ë””/ìŠ¤íŒŸ ======
    function rebuildSpotsAndParticles() { buildParticles(); buildHiddenSpots(); }
    function rebuildGrassAndSpots() { buildGrass(); buildHiddenSpots(); }

    function buildParticles() {
      const info = emotionTypes[state.emotion] || emotionTypes.neutral;
      const count = Math.floor(state.intensity * 20) + 5;
      const arr = [];
      for (let i=0;i<count;i++) {
        arr.push({
          x: Math.random() * state.screen.width,
          y: Math.random() * state.screen.height,
          size: Math.random() * 3 + 1,
          opacity: Math.random() * 0.3 + 0.1,
          speed: Math.random() * 0.5 + 0.2,
          angle: Math.random() * Math.PI * 2,
          color: info.color,
          type: info.particles
        });
      }
      state.particles = arr;
    }

    function randomGrassColor() {
      const hue = 100 + Math.random() * 30;
      const saturation = 70;
      const lightness = 25 + Math.random() * 20;
      return `hsl(${hue} ${saturation}% ${lightness}%)`;
    }

    function buildGrass() {
      const count = Math.floor((state.screen.width * state.screen.height) / 500);
      const arr = [];
      for (let i=0;i<count;i++) {
        arr.push({
          x: Math.random() * state.screen.width,
          baseY: state.screen.height - 10 - Math.random() * 200,
          height: 40 + Math.random() * 60,
          angle: 0,
          targetAngle: 0,
          width: 2 + Math.random() * 3,
          sway: STATIC_GRASS ? 0 : Math.random() * Math.PI * 2,
          swaySpeed: STATIC_GRASS ? 0 : 0.02 + Math.random() * 0.03,
          swayIntensity: STATIC_GRASS ? 0 : 0.01 + Math.random() * 0.03,
          springiness: 0.05 + Math.random() * 0.05,
          color: randomGrassColor()
        });
      }
      state.grass = arr;
    }

    function buildHiddenSpots() {
      const spots = [];
      // ë°œê²¬ ë¹ˆë„ ìƒí–¥: ê¸°ë³¸ ê°œìˆ˜ ì¦ê°€
      const count = Math.floor(state.intensity * 28) + 18;
      const m = 40;
      for (let i=0;i<count;i++) {
        spots.push({
          x: m + Math.random() * (state.screen.width - 2*m),
          y: m + Math.random() * (state.screen.height - 2*m),
          found: false,
          resonance: Math.random()
        });
      }
      state.hiddenSpots = spots;
    }

    // ====== ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ======
    let rafId = 0;
    function draw() {
      const ctx = state.ctx; if (!ctx) return;
      ctx.clearRect(0, 0, state.screen.width, state.screen.height);
      // ê° í”„ë ˆì„ ì‹œì‘ ì‹œ ì»¨í…ìŠ¤íŠ¸ ìƒíƒœ ì´ˆê¸°í™” (ë©”ì‹œì§€ ë“œë¡œì‰ì˜ alpha ëˆ„ìˆ˜ ë°©ì§€)
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';

      // 1) ë°°ê²½ ì´ë¯¸ì§€ containìœ¼ë¡œ ê·¸ë¦¬ê¸° (ë¹„ìœ¨ ìœ ì§€, ì „ì²´ ë³´ì„)
      if (state.backgroundImage) {
        drawContain(ctx, state.backgroundImage, state.screen.width, state.screen.height, 0.9);
      }

      // 2) íƒí—˜ ë‹¨ê³„ ì˜¤ë²„ë ˆì´
      if (state.phase === 'exploring') {
        const info = emotionTypes[state.emotion] || emotionTypes.neutral;
        const gradient = ctx.createRadialGradient(
          state.screen.width/2, state.screen.height/2, 0,
          state.screen.width/2, state.screen.height/2, state.screen.width
        );
        gradient.addColorStop(0, info.color + '20');
        gradient.addColorStop(1, info.color + '08');
        ctx.fillStyle = gradient;
        ctx.fillRect(0,0,state.screen.width,state.screen.height);
      }

      // 3) íŒŒí‹°í´
      state.particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.opacity;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        p.x += Math.cos(p.angle) * p.speed;
        p.y += Math.sin(p.angle) * p.speed;
        if (p.x < 0) p.x = state.screen.width;
        if (p.x > state.screen.width) p.x = 0;
        if (p.y < 0) p.y = state.screen.height;
        if (p.y > state.screen.height) p.y = 0;
        ctx.restore();
      });

      // 4) ì”ë””
      state.grass.forEach(blade => {
        let natural = 0;
        if (!STATIC_GRASS) {
          const d = blade.targetAngle - blade.angle;
          blade.angle += d * blade.springiness;
          blade.sway += blade.swaySpeed;
          natural = Math.sin(blade.sway) * blade.swayIntensity;
        } else {
          blade.angle = 0;
          blade.targetAngle = 0;
        }
        // ë§ˆìš°ìŠ¤ì˜¤ë²„ ì‹œ ìì—°ìŠ¤ëŸ¬ìš´ ê°ˆë¼ì§(íŒ/ì¤‘ê°„ì„ ë°”ê¹¥ìœ¼ë¡œ íœ˜ê²Œ) ì ìš©
        let tipOffsetX = 0;
        let controlOffsetX = 0;
        if (state.mouse.inside) {
          const dx = blade.x - state.mouse.x;
          const dy = blade.baseY - state.mouse.y;
          const dist = Math.hypot(dx, dy);
          const radius = 160; // ì˜í–¥ ë°˜ê²½
          if (dist < radius) {
            const strength = 1 - (dist / radius);
            const direction = Math.sign(dx) || 0; // ì¢Œìš° ë°©í–¥
            const maxTip = 24; // íŒì˜ ìµœëŒ€ ì¢Œìš° ì˜¤í”„ì…‹(px)
            tipOffsetX = direction * strength * maxTip;
            controlOffsetX = tipOffsetX * 0.5; // ì¤‘ê°„ì€ íŒì˜ ì ˆë°˜ ì •ë„ë§Œ ì´ë™
          }
        }

        ctx.save();
        ctx.translate(blade.x, blade.baseY);
        ctx.rotate(blade.angle + natural);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        // ë°”ê¹¥ìª½ìœ¼ë¡œ íœ˜ì–´ì§„ ì”ë”” í˜•ìƒ: ë² ì§€ì–´ ì»¨íŠ¸ë¡¤ê³¼ íŒ ìœ„ì¹˜ë¥¼ ì¢Œìš°ë¡œ ì´ë™
        ctx.quadraticCurveTo(blade.width/2 + controlOffsetX, -blade.height/2, tipOffsetX, -blade.height);
        ctx.quadraticCurveTo(-blade.width/2 + controlOffsetX, -blade.height/2, 0, 0);
        ctx.fillStyle = blade.color;
        ctx.fill();
        ctx.restore();
      });

      // 5) ì´ëª¨ì§€
      state.emojis.forEach(emoji => {
        ctx.save();
        ctx.globalAlpha = emoji.opacity;
        ctx.font = emoji.size + 'px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
        ctx.textAlign = 'center';
        ctx.fillText(emoji.symbol, emoji.x, emoji.y);
        ctx.restore();
      });

      // 6) í”Œë¡œíŒ… ë©”ì‹œì§€ (exploring ì¼ ë•Œë§Œ)
      if (state.phase === 'exploring') {
        state.floatingMessages.forEach(m => {
          ctx.save();
          const padding = 18;
          const lines = m.text.split('\n');
          const fontSize = 18 + m.scale * 6;
          const lineHeight = fontSize * 1.4;
          const boxH = lines.length * lineHeight + padding * 2;
          ctx.font = '500 ' + fontSize + 'px "Noto Sans KR", -apple-system, BlinkMacSystemFont, sans-serif';
          const maxW = Math.max(...lines.map(line => ctx.measureText(line).width));
          const boxW = maxW + padding * 2;
          const boxX = m.x - boxW/2; const boxY = m.y - boxH - 10;

          // ê·¸ë¦¼ì
          ctx.globalAlpha = m.opacity * 0.3; ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(boxX+3, boxY+3, boxW, boxH);
          // ë°•ìŠ¤
          ctx.globalAlpha = m.opacity * 0.85; ctx.fillStyle = 'rgba(255,255,255,0.85)';
          roundRect(ctx, boxX, boxY, boxW, boxH, 12);
          ctx.fill();
          // í…Œë‘ë¦¬
          ctx.globalAlpha = m.opacity * 0.45; ctx.strokeStyle = m.color; ctx.lineWidth = 2; ctx.stroke();
          // í…ìŠ¤íŠ¸
          ctx.globalAlpha = m.opacity; ctx.fillStyle = '#2D3748'; ctx.textAlign = 'center';
          lines.forEach((line, i) => { const y = boxY + padding + fontSize + (i * lineHeight); ctx.fillText(line, m.x, y); });
          // í¬ì¸íŠ¸
          ctx.globalAlpha = m.opacity * 0.8; ctx.fillStyle = m.color; ctx.beginPath(); ctx.arc(boxX + boxW - 10, boxY + 10, 4, 0, Math.PI*2); ctx.fill();
          ctx.restore();
        });
      }

      // í”„ë ˆì„ ì¢…ë£Œ ì‹œ ì»¨í…ìŠ¤íŠ¸ ìƒíƒœ ë³µì›
      ctx.restore();
      rafId = requestAnimationFrame(draw);
    }

    function drawContain(ctx, img, vw, vh, alpha=1) {
      const iw = img.naturalWidth || img.width; const ih = img.naturalHeight || img.height;
      const vr = vw / vh; const ir = iw / ih;
      let dw, dh, dx, dy;
      if (ir > vr) { // ì´ë¯¸ì§€ê°€ ë” ë„“ìŒ â†’ í­ ë§ì¶”ê³  ìƒí•˜ ë ˆí„°ë°•ìŠ¤
        dw = vw; dh = vw / ir; dx = 0; dy = (vh - dh) / 2;
      } else { // ì´ë¯¸ì§€ê°€ ë” ë†’ìŒ â†’ ë†’ì´ ë§ì¶”ê³  ì¢Œìš° ë ˆí„°ë°•ìŠ¤
        dh = vh; dw = vh * ir; dy = 0; dx = (vw - dw) / 2;
      }
      ctx.save(); ctx.globalAlpha = alpha; ctx.drawImage(img, dx, dy, dw, dh); ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.lineTo(x+w-r, y);
      ctx.quadraticCurveTo(x+w, y, x+w, y+r);
      ctx.lineTo(x+w, y+h-r);
      ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
      ctx.lineTo(x+r, y+h);
      ctx.quadraticCurveTo(x, y+h, x, y+h-r);
      ctx.lineTo(x, y+r);
      ctx.quadraticCurveTo(x, y, x+r, y);
      ctx.closePath();
    }

    // ====== ìƒí˜¸ì‘ìš© ======
    function handleMouseMove(e) {
      if (state.phase !== 'exploring') return;
      const rect = state.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      state.mouse = { x, y, inside: true };
      if (STATIC_GRASS) return; // ê³ ì • ëª¨ë“œ ì‹œ ê°ë„ ë³€ê²½ ìƒëµ
      const newGrass = state.grass.map(b => {
        const dist = Math.hypot(b.x - x, b.baseY - y);
        const radius = 100;
        if (dist < radius) {
          const strength = (radius - dist) / radius;
          const dx = b.x - x; const angle = Math.atan2(dx, 50) * strength * 0.5;
          return { ...b, targetAngle: angle };
        }
        return { ...b, targetAngle: 0 };
      });
      state.grass = newGrass;
    }

    function handleMouseLeave() {
      if (!STATIC_GRASS) {
        state.grass = state.grass.map(b => ({ ...b, targetAngle: 0 }));
      }
      state.mouse.inside = false;
    }

    function handleCanvasClick(e) {
      if (state.phase !== 'exploring') return;
      const rect = state.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      state.hiddenSpots.forEach((spot, idx) => {
        if (!spot.found) {
          const d = Math.hypot(spot.x - x, spot.y - y);
          if (d < 110) {
            createEmotionMessage(spot.x, spot.y, spot.resonance);
            createEmotionEmoji(spot.x, spot.y);
            const m = 40; const next = { x: m + Math.random() * (state.screen.width - 2*m), y: m + Math.random() * (state.screen.height - 2*m), found: false, resonance: Math.random() };
            const clone = state.hiddenSpots.slice(); clone[idx] = next; state.hiddenSpots = clone;
          }
        }
      });
    }

    // ====== ë©”ì‹œì§€/ì´ëª¨ì§€ ======
    let creating = false;
    function createEmotionMessage(x, y, resonance) {
      if (creating) return; creating = true;
      const info = emotionTypes[state.emotion] || emotionTypes.neutral;
      let type = 'gentle'; let color = info.color;
      if (resonance < 0.4) type = 'gentle'; else if (resonance < 0.7) type = 'understanding'; else { type = 'deep'; color = '#8E44AD'; }
      const examples = (messageExamples[state.emotion] || messageExamples.neutral)[type] || messageExamples.neutral.gentle;
      // ì¹´í…Œê³ ë¦¬ í•©ì‚° í’€ì„ ë§Œë“¤ì–´ ë‹¤ì–‘ì„±ì„ ê·¹ëŒ€í™”
      const pool = (
        (messageExamples[state.emotion]?.gentle || [])
        .concat(messageExamples[state.emotion]?.understanding || [])
        .concat(messageExamples[state.emotion]?.deep || [])
      );
      const candidates = (pool && pool.length >= 10) ? pool : examples;
      // ì„¸ì…˜ ì¤‘ë³µ ë°©ì§€: ìµœê·¼ 10ê°œ ë‚´ ì¤‘ë³µ íšŒí”¼, ìµœëŒ€ 15íšŒ ì¬ì‹œë„
      let text = '';
      const recent = state.recentMessages || [];
      for (let tries = 0; tries < 15; tries++) {
        text = candidates[Math.floor(Math.random() * candidates.length)] || 'ë‹¹ì‹ ì˜ ê°ì •ì„ ì´í•´í•˜ê³  í•¨ê»˜í•˜ê² ìŠµë‹ˆë‹¤';
        if (!recent.includes(text)) break;
      }
      // ìµœê·¼ ë©”ì‹œì§€ í ì—…ë°ì´íŠ¸(ìµœëŒ€ 10ê°œ ìœ ì§€)
      const nextRecent = (recent.concat(text)).slice(-10);
      state.recentMessages = nextRecent;
      addMessage(text, x, y, color, type);
      // ìƒì„± ì¿¨ë‹¤ìš´ì„ ì‚´ì§ ì¤„ì—¬ ë°œê²¬ ë¹ˆë„ ìƒí–¥
      setTimeout(() => creating = false, 30);
    }

    function addMessage(text, x, y, color, type) {
      state.foundMessages.push({ text, color, time: state.secondsExploring, type });
      showFloatingMessage(text, x, y, color);
      el.txtMsgCount.textContent = String(state.foundMessages.length);
    }

    function showFloatingMessage(text, x, y, color) {
      const maxLen = 25;
      let t = text;
      if (t.length > maxLen) {
        const mid = Math.floor(t.length / 2); t = t.substring(0, mid) + '\n' + t.substring(mid);
      }
      // ë©”ì‹œì§€ ë°€ë„ë¥¼ ë†’ì´ë˜ ê²¹ì¹¨ì€ ì™„í™”
      let px = x; let py = y - 100; const padding = 120; const minDist = 160; let tries = 0; let ok = false;
      while (!ok && tries < 10) {
        let coll = false; for (const p of state.activeMsgPositions) { if (Math.hypot(px - p.x, py - p.y) < minDist) { coll = true; break; } }
        if (!coll) ok = true; else {
          const ang = (tries * Math.PI * 2) / 8; const off = 80 + (tries * 20); px = x + Math.cos(ang) * off; py = y - 100 + Math.sin(ang) * off;
          if (px < padding) px = padding; if (px > state.screen.width - padding) px = state.screen.width - padding;
          if (py < 100) py = 100; if (py > state.screen.height - 100) py = state.screen.height - 100;
          tries++;
        }
      }
      const pos = { x: px, y: py, timestamp: Date.now() };
      // ìµœê·¼ í¬ì§€ì…˜ ìœ ì§€ ì‹œê°„ ë‹¨ì¶•í•´ ë” ìì£¼ ìƒì„± ê°€ëŠ¥
      state.activeMsgPositions = state.activeMsgPositions.filter(p => Date.now() - p.timestamp < 3500).concat([pos]);
      state.floatingMessages.push({ text: t, x: px, y: py, opacity: 1, scale: 0, color });
    }

    function createEmotionEmoji(x, y) {
      const list = emojiMap[state.emotion] || emojiMap.neutral; const sym = list[Math.floor(Math.random()*list.length)];
      state.emojis.push({ symbol: sym, x: x + (Math.random()-0.5)*30, y: y + Math.random()*10, opacity: 1, size: 24 + Math.random()*8, speed: 1.5 + Math.random()*1 });
    }

    // ====== íƒ€ì´ë¨¸/ë£¨í”„ ì—…ë°ì´íŠ¸ ======
    function startTimer() {
      stopTimer();
      state.timerRunning = true; const startTs = Date.now() - state.secondsExploring * 1000;
      state.timerInterval = setInterval(() => {
        state.secondsExploring = Math.floor((Date.now() - startTs) / 1000);
        el.txtTime.textContent = formatTimer(state.secondsExploring);
      }, 1000);
    }
    function stopTimer() { if (state.timerInterval) { clearInterval(state.timerInterval); state.timerInterval = null; } state.timerRunning = false; }
    function formatTimer(total) { const m = Math.floor(total / 60); const s = total % 60; return m + ':' + String(s).padStart(2,'0'); }

    // ====== íë¦„ ì œì–´ ======
    function startExploration() {
      state.transitioning = true;
      setTimeout(() => {
        state.phase = 'exploring'; state.transitioning = false;
        el.welcome.style.display = 'none'; el.hud.style.display = ''; el.hint.style.display = '';
        startTimer();
      }, 200);
    }
    function finishExploration() {
      state.transitioning = true;
      setTimeout(() => {
        state.phase = 'results'; state.transitioning = false; stopTimer(); el.hud.style.display = 'none'; el.hint.style.display = 'none'; el.results.style.display = '';
        el.summaryTime.textContent = formatTimer(state.secondsExploring); el.summaryCount.textContent = String(state.foundMessages.length);
        renderMessageList();
      }, 200);
    }
    function restartGame() {
      state.transitioning = true;
      setTimeout(() => {
        state.phase = 'welcome'; state.transitioning = false; stopTimer();
        state.secondsExploring = 0; state.foundMessages = []; state.floatingMessages = []; state.emojis = []; state.activeMsgPositions = [];
        el.txtTime.textContent = '0:00'; el.txtMsgCount.textContent = '0';
        el.hud.style.display = 'none'; el.hint.style.display = 'none'; el.results.style.display = 'none'; el.welcome.style.display = '';
      }, 200);
    }

    function updateHUDEmotion() {
      const info = emotionTypes[state.emotion] || emotionTypes.neutral; el.txtEmotion.textContent = info.label || 'ì¤‘ë¦½';
    }

    function renderMessageList() {
      el.messageList.innerHTML = '';
      if (!state.foundMessages.length) {
        const p = document.createElement('p'); p.textContent = 'ì•„ì§ ë©”ì‹œì§€ë¥¼ ì°¾ì§€ ëª»í–ˆì–´ìš”. ë‹¤ì‹œ í•œë²ˆ ê°ì •ì„ íƒí—˜í•´ë³´ì„¸ìš”.'; p.style.cssText = 'color:#333; font:300 14px "Noto Sans KR", sans-serif;'; el.messageList.appendChild(p);
        return;
      }
      state.foundMessages.forEach(m => {
        const row = document.createElement('div');
        row.style.cssText = 'margin:6px 0; padding:10px 12px; border-radius:10px; background: rgba(175,225,175,0.35); color:#222; display:flex; justify-content:space-between; align-items:center;';
        const span = document.createElement('span'); span.textContent = m.text; span.style.cssText = 'font:400 14px "Noto Sans KR", sans-serif;';
        const tm = document.createElement('span'); tm.textContent = formatTimer(m.time); tm.style.cssText = 'color:#555; font:300 12px "Noto Sans KR", sans-serif;';
        row.appendChild(span); row.appendChild(tm); el.messageList.appendChild(row);
      });
    }

    // ====== ë©”ì¸ ======
    (function main() {
      initDom();

      // ê°ì •/ê°•ë„ ì´ˆê¸°í™” (ë¶„ì„ ê²°ê³¼ ì ìš©)
      state.emotion = pickEmotion();
      state.intensity = pickIntensity();
      el.selectEmotion.value = state.emotion;
      el.rangeIntensity.value = String(state.intensity);
      el.intensityText.textContent = Math.round(state.intensity * 100) + '%';
      updateHUDEmotion();

      // ë°°ê²½ ë¡œë“œ (ë¸ŒëŸ¬ì‹œ íš¨ê³¼ ê²°ê³¼)
      loadBackgroundImageIfAny();

      // ì¥ë©´ êµ¬ì„±
      buildGrass();
      rebuildSpotsAndParticles();

      // ìë™ ì‹œì‘: emotion ë˜ëŠ” bgê°€ ìˆìœ¼ë©´ ë°”ë¡œ ì‹œì‘
      const autoStart = !!pickBackgroundUrl() || getQueryParam('auto') === '1' || getQueryParam('autostart') === '1';
      if (autoStart) startExploration();

      // ë£¨í”„ + ì—…ë°ì´íŠ¸ íƒ€ì´ë¨¸
      rafId = requestAnimationFrame(draw);
      setInterval(() => {
        if (state.phase !== 'exploring') return;
        // ì´ëª¨ì§€/ë©”ì‹œì§€ í˜ì´ë“œì—…ë°ì´íŠ¸
        state.emojis = state.emojis.map(e => ({ ...e, y: e.y - e.speed, opacity: e.opacity - 0.01, size: e.size + 0.2 })).filter(e => e.opacity > 0);
        state.floatingMessages = state.floatingMessages.map(m => ({ ...m, y: m.y - 0.8, opacity: m.opacity - 0.004, scale: m.scale + 0.006 })).filter(m => m.opacity > 0);
      }, 16);
    })();
  </script>
</body>
</html>


