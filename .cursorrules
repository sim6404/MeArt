User Rules
README 명세를 사실의 단일 출처로 삼아 기능·스택·엔드포인트를 준수한다. 스택: Node.js+Express, HTML/CSS/Vanilla JS, U2Net/ONNX/TF Hub/REMBG, Python(OpenCV/Pillow)+Sharp, Firebase(옵션), Render 배포 지원.
모든 이미지 입력은 JPG/PNG/WEBP, ≤ 50MB를 검증하고 조기 반환(early return)으로 실패를 처리한다.
처리 단계(업로드 → 배경 제거 → 감정 분석 → 스타일 추천/적용 → 합성 → 다운로드)는 스트리밍 진행률과 로그를 남긴다. (진행률 표시는 README UX 목표)
성능 목표를 기준선으로 유지: 배경 3–8초, 감정 1–3초, 브러시 5–15초, 합성 1–2초(환경 의존). 회귀 시 최적화 우선.

Render 호스팅 최적화
포트 9000을 노출하고 /health 헬스체크를 제공한다.
render.yaml을 유지하고, 컨테이너 이미지가 빠르게 기동되도록 모델 사전 로딩을 지원한다.
메모리 사용량을 줄이기 위해 파일 스트리밍·임시파일 정리를 철저히 한다.
보안/신뢰성: 업로드 MIME/확장자/용량·경로 화이트리스트(Assets/BG_image/)·임시파일 정리·에러 메시지 일관화.
타입 안정성: TypeScript strict + RORO 패턴 + 인터페이스 우선, enum 지양(리터럴 유니온/맵).

Project Rules
1) API 설계 (Express)
라우트 최소화, 서비스 레이어에 도메인 로직 집중.
Endpoints
GET /health → 서버 상태/메모리/연결 상태.
POST /api/remove-bg (multipart: image 필수, backgroundPath?, emotion?) → 미리보기, 감정 분석, 추천, 메타데이터 반환.
POST /api/apply-brush-effect (JSON: nobgPath, backgroundPath, emotion) → 브러시 적용 결과.
모든 응답은 { ok|success, data?, error? } 형태를 유지하고, 예상 오류는 결과 타입으로 모델링.

2) 파이프라인 (AI/이미지)
순서: 배경 제거(U2Net+REMBG) → 감정 분석(ONNX, 7 클래스) → 명화 배경 추천(64) → Neural Style Transfer(브러시) → Sharp 합성(최종 4K 옵션).
Python 스크립트(emotion_analysis.py, u2net_remove_bg.py, brush_effect.py)는 Node에서 child_process로 호출하며, 표준출력(JSON line)로 진행률/결과를 교환한다.
Assets/BG_image/ 내부 자산만 배경으로 허용(화이트리스트).

3) 성능/안정화
스트리밍 처리(업로드·중간 산출물)를 기본으로 하여 메모리 상주 최소화.
동일 입력(파일 해시+파라미터)에 대한 결과/중간 캐싱.
타임아웃·리트라이·취소(AbortSignal)·워커 동시성 제어.
임시 디렉터리를 작업 ID 단위로 격리, 완료/실패 시 즉시 정리.

4) 프론트엔드 UX
드래그앤드롭 업로드, 실시간 처리 상태, 단계별 미리보기, 고해상도 다운로드, 모바일 최적화.
업로드 전 클라이언트 리사이즈/포맷 최적화를 고려(네트워크·서버 부하 감소).

5) 구성/배포
포트 9000 사용, 헬스체크 경로는 /health(Render Health Check에 등록).
배포 아티팩트: Dockerfile, render.yaml, env.example 유지 및 동기화.

ENV 권장:
PORT=9000
NODE_ENV=production
JWT_SECRET=your-secret-key
``` :contentReference[oaicite:26]{index=26}
6) 타입/응답 스키마(권장)
Remove‑BG 응답 예시는 README 형식을 그대로 따른다(프리뷰, emotionAnalysis{emotion,confidence,top_emotions}, artworkRecommendations[], metadata{processingTime,imageSize}).

7) 프로젝트 구조(가이드)
README 구조를 준수: Frontend/public, Assets(BG_image, uploads, models), AI Scripts(py), Backend/server.js, Deployment(Dockerfile, render.yaml …).